<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Authentication Plugin: OUA Shared Cookie Authentication
 * Authenticates against using a shared cookie generated by the he website
 *
 * @package auth_ouasharedcookie
 * @author Ben Kelada
 *
 */

defined('MOODLE_INTERNAL') || die();

require_once($CFG->libdir . '/authlib.php');
require_once($CFG->libdir . '/moodlelib.php');

/**
 * OUA Shared Cookie authentication plugin.
 */
class auth_plugin_ouasharedcookie extends auth_plugin_base {

    /**
     * Constructor.
     */
    public function __construct() {
        $this->authtype = 'ouasharedcookie';
        $this->config = get_config('auth/ouasharedcookie');
    }

    /**
     * ouasharedcookie uses loginpage_hook and pre_loginpage_hook to authenicate users.
     * This function is never called, see:
     * https://docs.moodle.org/dev/Authentication_plugins#Overview_of_Moodle_authentication_process
     *
     * @param string $username The username
     * @param string $password The password
     *
     * @return bool false always for this function as it's never called.
     */
    public function user_login($username, $password) {
        return false;
    }

    /**
     * Run this to login automatically or let the user continue to the login screen.
     */
    public function pre_loginpage_hook() {
        global $CFG;

        if (!function_exists('mcrypt_module_open')) {
            debugging(get_string('mcrypt_not_installed', 'auth_ouasharedcookie'), DEBUG_ALL);
            return;
        }

        $ouaid = $this->verify_cookie();

        if ($ouaid === false) {
            // We don't redirect as we can't be sure the user is using this authentication mechanism.
            return;
        }

        $user = $this->verify_user($ouaid);
        // If the user is verfied, complete their login.
        if ($user !== false) {
            complete_user_login($user);
            \core\session\manager::apply_concurrent_login_limit($user->id, session_id());
        }
    }

    /**
     * Complete a user login based on a valid id.
     *
     * @param integer $ouaid The idnumber of the user to attempt to complete the login for.
     *
     * @return stdClass|bool A complete user record of the logged in user or false on failure.
     */
    protected function verify_user($ouaid) {
        global $DB;

        try {
            $user = $DB->get_record('user', array('idnumber' => $ouaid, 'auth' => $this->authtype), '*', MUST_EXIST);
            $user = get_complete_user_data('id', $user->id);
        } catch (dml_multiple_records_exception $e) {
            // Multiple users are configured with this oua id.
            debugging('Multiple users have the same idnumber configured for this authtype. idnumber: '.$ouaid, DEBUG_ALL);
            return false;
        } catch (dml_missing_record_exception $e) {
            // No users are configured with this oua id.
            debugging('No users configured with idnumber for this authtype. idnumber: ' . $ouaid, DEBUG_ALL);
            return false;
        }

        return $user;
    }

    /**
     * When the login page for moodle has been requested, run this function.
     * We attempt to auto log the user in, or redirect to the alternative login page.
     */
    public function loginpage_hook() {
        global $user; // Used to replace authenticate_user_login()
        global $CFG, $SESSION;

        $redirect = optional_param('redirect', 1, PARAM_INT);
        $username = optional_param('username', '', PARAM_RAW);
        if ($redirect == 0 || isset($SESSION->nologinredirect)) {
            // Login page can redirect back to itself without parameters when there is an error message, e.g. session timeout.
            // Remember the redirect = 0 paramater accross this redirect using this custom session var.
            $SESSION->nologinredirect = true;
            return;
        }
        // If the username is set for the form, we will not validate or redirect.
        if (!empty($username) || isloggedin()) {
            return;
        }

        if (!function_exists('mcrypt_module_open')) {
            debugging(get_string('mcrypt_not_installed', 'auth_ouasharedcookie'), DEBUG_ALL);
            return;
        }

        // Prevent username from being shown on login page after logout.
        $CFG->nolastloggedin = true;

        // We went to the login page, check if they are already authenticated
        $ouaid = $this->verify_cookie();

        // Cookie was not verified
        if ($ouaid === false || ($user = $this->verify_user($ouaid)) !== false) {
            // Set the alternative login url to ours if it's not already set by a higher
            // priority plugin.
            if (!empty($this->config->shared_login_url) && empty($CFG->alternateloginurl)) {
                $CFG->alternateloginurl = $this->config->shared_login_url;
            }
            return;
        }

        // A valid cookie was found, but not a valid user.  Assume a login without an account.
        if ($ouaid !== false && $user === false) {
            if (!empty($this->config->no_account_url) && empty($CFG->alternateloginurl)) {
                // Defined no user URL, send the person there via redirect
                $CFG->alternateloginurl = $this->config->no_account_url;
            }
            return;
        }

    }

    /**
     * Verify a cookie we have recieve and determine the user it belongs to.
     *
     * @return integer|bool If the cookie was valid return the id, false otherwise.
     */
    protected function verify_cookie() {
        if (!isset($_COOKIE[$this->config->cookie_name])) {
            return false;
        }

        // The cookie can be encoded incorrectly with spaces instead of +'s in URL enoding.
        $string = $_COOKIE[$this->config->cookie_name];
        $string = str_replace(' ', '+', $string);

        $userdata = $this->decrypt_cookie($string);

        // Both time and id are integers, so all extra :'s must belong to the username.
        if (!preg_match_all('/^(\d+):(.*):(\d+)$/', $userdata, $parts)) {
            debugging("ouasharedcookie: Cookie corrupt or missing data. ".
                "Failed to match cookie data with format /^(\\d+):(.*):(\\d+)$/: ".$userdata, DEBUG_ALL);
            return false;
        }

        $ouaid = $parts[1][0];

        // The time sent to us in in milliseconds, we want calculations in sections.
        $timest = floor($parts[3][0] / 1000);
        $now = time();

        // Check if creation is more than timeout old.
        if (($timest + $this->config->timeout) < $now) {
            debugging("ouasharedcookie: Cookie is too old. Data: ".$userdata);
            return false;
        }

        // Check if creation is in the future with a five minute slack
        $allowedclockskew = 5 * 60;
        if ($now < ($timest - $allowedclockskew)) {
            debugging("ouasharedcookie: Rejecting cookie with timestamp from the future. Data: ".$userdata, DEBUG_ALL);
            return false;
        }

        return $ouaid;
    }

    /**
     * Upon logout remove the cookie to ensure we won't automatically log back in.
     */
    function logoutpage_hook() {
        global $USER;
        if ($USER->auth === $this->authtype && isset($this->config->dosinglelogout) && $this->config->dosinglelogout) {
            unset($_COOKIE[$this->config->cookie_name]);
            setcookie($this->config->cookie_name, null, -1, '/', $this->config->shared_cookie_domain);
        }
    }

    /**
     * Determine the url (if any) to send the user to after logout.
     *
     * @param stdClass $user The user record just prior to logout.
     */
    public function postlogout_hook($user) {
        global $redirect;  // This is used to completed a redirect after a user has logged out.

        // Only do this if the user is actually logged in via ouasharedcookie.
        if ($user->auth === $this->authtype) {
            // Check if there is an alternative logout url defined
            if (isset($this->config->logout_url) && !empty($this->config->logout_url)) {
                $redirect = $this->config->logout_url;
            }
        }
    }

    /**
     * Does this plugin prevent moodle database based passwords.
     *
     * @return bool true.
     */
    public function prevent_local_passwords() {
        return true;
    }

    /**
     * Returns true if this authentication plugin is 'internal'.
     *
     * @return bool
     */
    function is_internal() {
        return false;
    }

    /**
     * The location to send a user if they want to change their password.
     *
     * @return moodle_url|null The url of password change or null if there isn't one.
     */
    function change_password_url() {
        return !empty($this->config->changepasswordurl) ? new moodle_url($this->config->change_password_url) : null;
    }

    /**
     * Returns true if this authentication plugin can change the user's
     * password.
     *
     * @return bool
     */
    function can_change_password() {
        return !empty($this->config->changepasswordurl);
    }

    /**
     * Prints a form for configuring this authentication plugin.
     *
     * This function is called from admin/auth.php, and outputs a full page with
     * a form for configuring this plugin.
     *
     * @param object $config An object containing all the configuration settings for this page.
     * @param object $err Any error string that should be displayed.
     * @param array $user_fields
     */
    function config_form($config, $err, $user_fields) {
        global $OUTPUT;
        if (!function_exists('mcrypt_module_open')) {
            debugging(get_string('mcrypt_not_installed', 'auth_ouasharedcookie'), DEBUG_ALL);
            echo $OUTPUT->notification(get_string('mcrypt_not_installed', 'auth_ouasharedcookie'));
            return;
        }
        include "config.html";
    }

    /**
     * Processes and stores configuration data for this authentication plugin, adding required defaults.
     *
     * @param stdClass $config The current configuration.
     * @return bool true always.
     */
    function process_config($config) {
        if (!isset ($config->secret)) {
            $config->secret = 'bilbo';
        }
        if (!isset ($config->shared_login_url)) {
            $config->shared_login_url = 'https://www.open.edu.au/login/form?success=';
        }
        if (!isset ($config->no_account_url)) {
            $config->no_account_url = '';
        }
        if (!isset ($config->logout_url)) {
            $config->logout_url = 'https://www.open.edu.au/login/do-logout';
        }
        if (!isset ($config->change_password_url)) {
            $config->change_password_url = 'https://www.open.edu.au/my-study-centre/my-profile/settings';
        }
        if (!isset ($config->cookie_name)) {
            $config->cookie_name = 'oua_lms_cookie';
        }
        if (!isset ($config->shared_cookie_domain)) {
            $config->shared_cookie_domain = '.open.edu.au';
        }
        if (!isset ($config->dosinglelogout)) {
            $config->dosinglelogout = true;
        }
        if (!isset ($config->iterations)) {
            $config->iterations = 1000;
        }
        if (!isset ($config->timeout)) {
            $config->timeout = 3600;
        }

        // save settings
        set_config('secret', $config->secret, 'auth/ouasharedcookie');
        set_config('shared_login_url', $config->shared_login_url, 'auth/ouasharedcookie');
        set_config('no_account_url', $config->no_account_url, 'auth/ouasharedcookie');
        set_config('logout_url', $config->logout_url, 'auth/ouasharedcookie');
        set_config('change_password_url', $config->change_password_url, 'auth/ouasharedcookie');
        set_config('cookie_name', $config->cookie_name, 'auth/ouasharedcookie');
        set_config('shared_cookie_domain', $config->shared_cookie_domain, 'auth/ouasharedcookie');
        set_config('dosinglelogout', $config->dosinglelogout === 'on', 'auth/ouasharedcookie');
        set_config('iterations', $config->iterations, 'auth/ouasharedcookie');
        set_config('timeout', $config->timeout, 'auth/ouasharedcookie');

        return true;
    }

    /**
     * Build an initialisation vector and key for the block cipher.
     *
     * @param $salt string The one time encryption/decryption string.
     * @return array $iv, $key as a list.
     */
    protected function build_iv_and_key($salt) {
        $unpackedpassword = unpack('H*', $this->config->secret);

        // Build the IV and Secret Key from the from the password and salt.
        $dk = array_shift($unpackedpassword) . $salt;
        for ($i = 0; $i < $this->config->iterations; $i++) {
            $packed = pack("H*", $dk);
            $dk = md5($packed);
        }
        $key = pack("H*", substr($dk, 0, 16));
        $iv = pack("H*", substr($dk, 16));

        return array($iv, $key);
    }

    /**
     * Decrypts cookie using PBEwithMD5andDES
     *
     * @param $input string the value to encode or decode
     *
     * @return string encrypted or decrypted value based on initial conditions.
     */
    public function decrypt_cookie($input) {
        $data = bin2hex(base64_decode($input));
        $salt = substr($data, 0, 16);
        $encrypteddata = pack("H*", substr($data, 16));

        list($iv, $key) = $this->build_iv_and_key($salt);

        // Decrypt the text block.
        $cipher = mcrypt_module_open(MCRYPT_DES, '', MCRYPT_MODE_CBC, '');
        mcrypt_generic_init($cipher, $key, $iv);
        $text = mdecrypt_generic($cipher, $encrypteddata);
        mcrypt_generic_deinit($cipher);
        mcrypt_module_close($cipher);

        // Remove padding from the output.
        $a = substr($text, -1); // Last character contains the amount of padding.
        $b = unpack('C', $a); // Unpack that character as unsigned integer value.
        $padding = reset($b);

        $text = substr($text, 0, strlen($text) - $padding);
        return $text;
    }

    /**
     * Encrypt a cookie, not currently used as OUA HE website creates the cookie.
     * Used for testing and verification purposes.
     *
     * @param $ouaid integer OUA ID to encrypt into the cookie.
     * @param $username string user's username for reference when decrypted.
     * @param $timest integer indicate cookie creation time, null to use current time.
     * @return string A base64 encoded encrypted string.
     */
    public function encrypt_cookie($ouaid, $username, $timest = null) {
        if ($timest === null) {
            $timest = time();
        }

        $text = $ouaid.":".$username.":".$timest;

        // Pad the string to a multiple of 128bit, last 8 bits is padding.
        $length = strlen($text);
        $padding = 8 - ($length % 8);
        $text = $text . str_repeat(' ', $padding-1);
        $text .= pack('C', $padding);
        $paddedtext = $text;

        // The salt must be a 16 bytes hex value.
        $salt = substr(md5(mt_rand()), 0, 16);

        list($iv, $key) = $this->build_iv_and_key($salt);
        // Encrypt the string.
        // Based on the cipher type, this will be 16bytes.
        $cipher = mcrypt_module_open(MCRYPT_DES, '', MCRYPT_MODE_CBC, '');
        mcrypt_generic_init($cipher, $key, $iv);
        $encryptedtext = mcrypt_generic($cipher, $paddedtext);
        mcrypt_generic_deinit($cipher);
        mcrypt_module_close($cipher);

        $binaryencrypted = $salt.bin2hex($encryptedtext);
        $base64final = base64_encode(hex2bin($binaryencrypted));

        return $base64final;
    }
}
